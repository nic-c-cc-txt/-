"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ESLintRunner = void 0;
const child_process_1 = require("child_process");
const path_1 = require("path");
const cache_1 = require("@thi.ng/cache");
const upath_1 = require("upath");
const server = require("vscode-languageserver");
const ConfigNotFoundMessage_1 = require("../Diagnostics/ConfigNotFoundMessage");
const DeprecationMessage_1 = require("../Diagnostics/DeprecationMessage");
const DiagnosticMessage_1 = require("../Diagnostics/DiagnosticMessage");
const ESLintDiagnostic_1 = require("../Diagnostics/ESLintDiagnostic");
const ESLintNotInstalledMessage_1 = require("../Diagnostics/ESLintNotInstalledMessage");
const LogLevel_1 = require("../Logging/LogLevel");
const RunnerLogger_1 = require("../Logging/RunnerLogger");
const PackageManager_1 = require("../Settings/PackageManager");
/**
 * Provides the functionality to run ESLint.
 */
class ESLintRunner {
    /**
     * Initializes a new instance of the `ESLintRunner` class.
     *
     * @param plugin
     * The plugin of the runner.
     */
    constructor(plugin) {
        /**
         * A set of documents and functions for resolving their linter.
         */
        // eslint-disable-next-line deprecation/deprecation
        this.document2LibraryCache = new cache_1.MRUCache([], { maxsize: 100 });
        /**
         * The paths to the package-managers.
         */
        this.packageManagerPaths = new Map();
        this.plugin = plugin;
    }
    /**
     * Gets the plugin of the runner.
     */
    get Plugin() {
        return this.plugin;
    }
    /**
     * Gets the typescript-server.
     */
    get TypeScript() {
        return this.Plugin.TypeScript;
    }
    /**
     * Gets a component for writing log-messages.
     */
    get RealLogger() {
        return this.Plugin.RealLogger.CreateSubLogger(ESLintRunner.name);
    }
    /**
     * Gets a component for writing log-messages.
     */
    get Logger() {
        if (this.Config.LogLevel !== LogLevel_1.LogLevel.None) {
            return this.RealLogger;
        }
        else {
            return null;
        }
    }
    /**
     * Gets a component for writing log-messages.
     */
    get RunnerLogger() {
        if (this.Config.LogLevel !== LogLevel_1.LogLevel.None) {
            return new RunnerLogger_1.RunnerLogger(this.RealLogger);
        }
        else {
            return null;
        }
    }
    /**
     * Gets the configuration of the plugin.
     */
    get Config() {
        return this.Plugin.Config;
    }
    /**
     * Gets the program of the language-server.
     */
    get Program() {
        return this.Plugin.Program;
    }
    /**
     * Gets the language-service host.
     */
    get LanguageServiceHost() {
        return this.Plugin.LanguageServiceHost;
    }
    /**
     * Checks a file using `eslint`.
     *
     * @param file
     * The file to check.
     *
     * @returns
     * The result of the lint.
     */
    RunESLint(file) {
        var _a, _b, _c, _d, _e, _f, _g;
        let result = [];
        (_a = this.RunnerLogger) === null || _a === void 0 ? void 0 : _a.Log("RunESLint", "Starting…");
        if (!this.document2LibraryCache.has(file.fileName)) {
            (_b = this.RunnerLogger) === null || _b === void 0 ? void 0 : _b.Log("RunESLint", "Preparing to load the `eslint` library");
            this.document2LibraryCache.set(file.fileName, this.LoadLibrary(file.fileName));
        }
        (_c = this.RunnerLogger) === null || _c === void 0 ? void 0 : _c.Log("RunESLint", "Loading the `eslint` library");
        // eslint-disable-next-line deprecation/deprecation
        let linter = (_d = this.document2LibraryCache.get(file.fileName)) === null || _d === void 0 ? void 0 : _d();
        if (!linter) {
            (_e = this.RunnerLogger) === null || _e === void 0 ? void 0 : _e.Log("RunESLint", "The `eslint` package is not installed!");
            this.document2LibraryCache.delete(file.fileName);
            result.push(new ESLintNotInstalledMessage_1.ESLintNotInstalledMessage(this.Plugin, file, this.TypeScript.DiagnosticCategory.Warning));
        }
        else {
            (_f = this.RunnerLogger) === null || _f === void 0 ? void 0 : _f.Log("RunESLint", "Successfully loaded the `eslint` package", LogLevel_1.LogLevel.Verbose);
            (_g = this.RunnerLogger) === null || _g === void 0 ? void 0 : _g.Log("RunESLint", `Validating '${file.fileName}'…`);
            result.push(...this.Run(file, linter));
        }
        return result;
    }
    /**
     * Checks a file using `eslint`.
     *
     * @param file
     * The file to check.
     *
     * @param linter
     * The linter.
     *
     * @returns
     * The result of the lint.
     */
    // eslint-disable-next-line deprecation/deprecation
    Run(file, linter) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        let result = [];
        let currentDirectory = process.cwd();
        let scriptKind = this.LanguageServiceHost.getScriptKind(file.fileName);
        (_a = this.RunnerLogger) === null || _a === void 0 ? void 0 : _a.Log("Run", `Starting validation for ${file.fileName}…`);
        (_b = this.RunnerLogger) === null || _b === void 0 ? void 0 : _b.Log("Run", "Detecting the ScriptKind of the file…");
        (_c = this.RunnerLogger) === null || _c === void 0 ? void 0 : _c.Log("Run", `${file.fileName} is a ${this.TypeScript.ScriptKind[this.LanguageServiceHost.getScriptKind(file.fileName)]}-file`);
        (_d = this.RunnerLogger) === null || _d === void 0 ? void 0 : _d.Log("Run", "Printing the configuration for the file…");
        (_e = this.RunnerLogger) === null || _e === void 0 ? void 0 : _e.Log("Run", this.Config.ToJSON());
        process.chdir(this.Program.getCurrentDirectory());
        try {
            if (linter.isPathIgnored(file.fileName) ||
                (this.Config.IgnoreJavaScript && [this.TypeScript.ScriptKind.JS, this.TypeScript.ScriptKind.JSX].includes(scriptKind)) ||
                (this.Config.IgnoreTypeScript && [this.TypeScript.ScriptKind.TS, this.TypeScript.ScriptKind.TSX].includes(scriptKind))) {
                (_f = this.RunnerLogger) === null || _f === void 0 ? void 0 : _f.Log("Run", `No linting: File ${file.fileName} is excluded`);
            }
            else {
                let fileName = upath_1.normalize(file.fileName);
                let lintFileName;
                if (fileName.startsWith("^") ||
                    ((fileName.includes("walkThroughSnippet:/") ||
                        fileName.includes("untitled:/")) &&
                        upath_1.basename(fileName).startsWith("^")) ||
                    (fileName.includes(":^") && !fileName.includes(upath_1.sep))) {
                    lintFileName = null;
                }
                else {
                    lintFileName = fileName;
                }
                (_g = this.RunnerLogger) === null || _g === void 0 ? void 0 : _g.Log("Run", "Linting: Start linting…");
                let report = linter.executeOnText(file.getFullText(), ...(lintFileName ? [lintFileName] : []));
                (_h = this.RunnerLogger) === null || _h === void 0 ? void 0 : _h.Log("Run", "Linting: Ended linting");
                for (let deprecatedRuleUse of report.usedDeprecatedRules) {
                    result.push(new DeprecationMessage_1.DeprecationMessage(this.Plugin, file, deprecatedRuleUse, this.TypeScript.DiagnosticCategory.Warning));
                }
                for (let lintResult of report.results) {
                    for (let message of lintResult.messages) {
                        result.push(new ESLintDiagnostic_1.ESLintDiagnostic(this.Plugin, file, message));
                    }
                }
            }
        }
        catch (exception) {
            let diagnostic;
            (_j = this.RunnerLogger) === null || _j === void 0 ? void 0 : _j.Log("Run", "An error occurred while linting");
            (_k = this.RunnerLogger) === null || _k === void 0 ? void 0 : _k.Log("Run", exception);
            if (exception instanceof Error) {
                (_l = this.RunnerLogger) === null || _l === void 0 ? void 0 : _l.Log("Run", `Stack trace: ${exception.stack}`);
            }
            if (exception instanceof Error &&
                exception.constructor.name === "ConfigurationNotFoundError") {
                diagnostic = new ConfigNotFoundMessage_1.ConfigNotFoundMessage(this.Plugin, file, exception, this.TypeScript.DiagnosticCategory.Warning);
            }
            else {
                diagnostic = new DiagnosticMessage_1.DiagnosticMessage(this.Plugin, file, `An error occurred while linting:\n${exception}`, this.TypeScript.DiagnosticCategory.Error);
            }
            result.push(diagnostic);
        }
        process.chdir(currentDirectory);
        return result;
    }
    /**
     * Determines the path to the specified `packageManager`.
     *
     * @param packageManager
     * The package-manager to get the path.
     *
     * @returns
     * The path to the global module-directory of the specified `PackageManager`.
     */
    GetPackageManagerPath(packageManager) {
        var _a, _b;
        (_a = this.RunnerLogger) === null || _a === void 0 ? void 0 : _a.Log("GetPackageManagerPath", `Trying to resolve the package manager path for ${packageManager}`);
        if (!this.packageManagerPaths.has(packageManager)) {
            let path;
            switch (packageManager) {
                case PackageManager_1.PackageManager.NPM:
                    path = child_process_1.execSync("npm root -g").toString().trim();
                    break;
                case PackageManager_1.PackageManager.Yarn:
                    path = server.Files.resolveGlobalYarnPath((message) => { var _a; return (_a = this.Logger) === null || _a === void 0 ? void 0 : _a.Info(message); });
                    break;
                case PackageManager_1.PackageManager.PNPM:
                    path = child_process_1.execSync("pnpm root -g").toString().trim();
                    break;
            }
            this.packageManagerPaths.set(packageManager, path);
        }
        (_b = this.RunnerLogger) === null || _b === void 0 ? void 0 : _b.Log("GetPackageManagerPath", `Found the package manager path for ${packageManager}`);
        return this.packageManagerPaths.get(packageManager);
    }
    /**
     * Loads the `CLIEngine` for the file with the specified `filePath`.
     *
     * @param filePath
     * The file to check.
     *
     * @returns
     * A method for loading the `CLIEngine`.
     */
    // eslint-disable-next-line deprecation/deprecation
    LoadLibrary(filePath) {
        var _a, _b, _c;
        (_a = this.RunnerLogger) === null || _a === void 0 ? void 0 : _a.Log("LoadLibrary", `Trying to load 'eslint' for '${filePath}'`);
        /**
         * Resolves the global module-directory.
         *
         * @returns
         * The path to the global module-directory.
         */
        let getGlobalPath = () => this.GetPackageManagerPath(this.Config.PackageManager);
        let directory = upath_1.dirname(filePath);
        let esLintPath;
        try {
            esLintPath = this.ResolveESLint(undefined, directory);
            if (esLintPath.length === 0) {
                esLintPath = this.ResolveESLint(getGlobalPath(), directory);
            }
        }
        catch (_d) {
            esLintPath = this.ResolveESLint(getGlobalPath(), directory);
        }
        if (esLintPath.length === 0) {
            (_b = this.RunnerLogger) === null || _b === void 0 ? void 0 : _b.Log("LoadLibrary", "The `eslint` module could not be found!");
            return () => null;
        }
        else {
            (_c = this.RunnerLogger) === null || _c === void 0 ? void 0 : _c.Log("LoadLibrary", `Resolves 'eslint' to '${esLintPath}'`, LogLevel_1.LogLevel.Verbose);
            // eslint-disable-next-line deprecation/deprecation
            return () => {
                // eslint-disable-next-line deprecation/deprecation
                let linter;
                let library;
                /**
                 * Creates a new `CLIEngine`.
                 *
                 * @returns
                 * The newly created `CLIEngine`.
                 */
                // eslint-disable-next-line deprecation/deprecation
                let createEngine = () => {
                    var _a, _b;
                    let currentDirectory = process.cwd();
                    (_a = this.RunnerLogger) === null || _a === void 0 ? void 0 : _a.Log("LoadLibrary", "Dumping the configuration", LogLevel_1.LogLevel.Verbose);
                    (_b = this.RunnerLogger) === null || _b === void 0 ? void 0 : _b.Log("LoadLibrary", this.Config.ToJSON(), LogLevel_1.LogLevel.Verbose);
                    process.chdir(this.Program.getCurrentDirectory());
                    // eslint-disable-next-line deprecation/deprecation
                    let result = new library.CLIEngine({
                        cache: true,
                        allowInlineConfig: this.Config.AllowInlineConfig,
                        reportUnusedDisableDirectives: this.Config.ReportUnusedDisableDirectives,
                        useEslintrc: this.Config.UseESLintRC,
                        configFile: this.Config.ConfigFile
                    });
                    process.chdir(currentDirectory);
                    return result;
                };
                try {
                    library = require(esLintPath);
                    linter = createEngine();
                }
                catch (_a) {
                    linter = undefined;
                }
                return linter;
            };
        }
    }
    /**
     * Resolves the path to the `eslint`-library.
     *
     * @param nodePath
     * The global path to resolve modules.
     *
     * @param cwd
     * The directory to resolve `eslint` from.
     *
     * @returns
     * The path to the `eslint`-module.
     */
    ResolveESLint(nodePath, cwd) {
        let env = Object.assign({}, process.env);
        let nodePathKey = "NODE_PATH";
        let app = [
            `
            try
            {
                console.log(require.resolve('eslint'));
            }
            catch
            {
                console.log("");
            }`
        ].join("");
        if (nodePath) {
            if (nodePathKey in env) {
                env[nodePathKey] = nodePath + path_1.delimiter + env[nodePathKey];
            }
            else {
                env[nodePathKey] = nodePath;
            }
        }
        env.ELECTRON_RUN_AS_NODE = "1";
        return child_process_1.spawnSync(process.argv0, ["-e", app], { cwd, env }).stdout.toString().trim();
    }
}
exports.ESLintRunner = ESLintRunner;
//# sourceMappingURL=ESLintRunner.js.map