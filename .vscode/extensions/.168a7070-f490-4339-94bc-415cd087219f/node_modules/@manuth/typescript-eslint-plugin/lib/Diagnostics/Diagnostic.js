"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Diagnostic = void 0;
const Constants_1 = require("../Constants");
/**
 * Represents a diagnostic.
 */
class Diagnostic {
    /**
     * Initializes a new instance of the `Diagnostic` class.
     *
     * @param plugin
     * The plugin of the diagnostic.
     *
     * @param file
     * The file of the diagnostic.
     *
     * @param category
     * The category of the diagnostic.
     */
    constructor(plugin, file, category) {
        this.plugin = plugin;
        this.file = file;
        this.category = category !== null && category !== void 0 ? category : this.TypeScript.DiagnosticCategory.Warning;
    }
    /**
     * Gets the plugin of the diagnostic.
     */
    get Plugin() {
        return this.plugin;
    }
    /**
     * Gets the typescript server.
     */
    get TypeScript() {
        return this.Plugin.TypeScript;
    }
    /**
     * Gets the configuration of the plugin.
     */
    get Config() {
        return this.Plugin.Config;
    }
    /**
     * Gets the source of the diagnostic.
     */
    get Source() {
        return Constants_1.Constants.ErrorSource;
    }
    /**
     * Gets the code of the error.
     */
    get Code() {
        return Constants_1.Constants.ErrorCode;
    }
    /**
     * Gets the category of the diagnostic.
     */
    get Category() {
        return this.category;
    }
    /**
     * Gets the source-file.
     */
    get File() {
        return this.file;
    }
    /**
     * Gets the range containing the error.
     */
    get Range() {
        return {
            start: {
                line: 0,
                character: 0
            },
            end: {
                line: 0,
                character: 0
            }
        };
    }
    /**
     * Gets the parsed representation of the diagnostic.
     */
    get Parsed() {
        let start = this.ResolvePosition(this.Range.start.line, this.Range.start.character);
        let end = this.ResolvePosition(this.Range.end.line, this.Range.end.character);
        return Object.assign(Object.assign({ category: this.Category, source: this.Source, code: this.Code, file: this.File, start, length: end - start, messageText: this.Message }, (this.RelatedInformation ?
            { relatedInformation: this.RelatedInformation } :
            {})), { origin: this });
    }
    /**
     * Resolves the position of a line- and column-number.
     *
     * @param line
     * The line to resolve.
     *
     * @param column
     * The column to resolve.
     *
     * @returns
     * A number representing the text-position.
     */
    ResolvePosition(line, column) {
        let result;
        if (line !== null && line !== undefined) {
            let lineStarts = this.File.getLineStarts();
            if (line < lineStarts.length) {
                let lineStart = lineStarts[line];
                let lineEnd = this.File.getLineEndOfPosition(lineStart);
                if (isNaN(lineEnd)) {
                    lineEnd = 0;
                }
                if (column !== null && column !== undefined) {
                    if (column <= (this.File.getLineEndOfPosition(lineStart) - lineStart)) {
                        result = this.File.getPositionOfLineAndCharacter(line, column);
                    }
                    else {
                        result = lineEnd;
                    }
                }
            }
            else {
                result = this.File.getLineEndOfPosition(lineStarts[lineStarts.length - 1]);
            }
        }
        else {
            result = null;
        }
        return result;
    }
}
exports.Diagnostic = Diagnostic;
//# sourceMappingURL=Diagnostic.js.map