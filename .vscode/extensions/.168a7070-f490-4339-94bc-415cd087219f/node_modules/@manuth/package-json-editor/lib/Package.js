"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Package = void 0;
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const gitRemoteOriginUrl = require("git-remote-origin-url");
const gitRootDir = require("git-root-dir");
const normalize = require("normalize-package-data");
const readmeFilename = require("readme-filename");
const Path = require("upath");
const PropertyDictionary_1 = require("./Collections/PropertyDictionary");
const GenerationLogic_1 = require("./GenerationLogic");
const LoadLogic_1 = require("./LoadLogic");
const BugInfo_1 = require("./Management/BugInfo");
const OrderedDependencyCollection_1 = require("./Management/OrderedDependencyCollection");
const Person_1 = require("./Management/Person");
const JSONObject_1 = require("./Utilities/JSONObject");
const JSONObjectBase_1 = require("./Utilities/JSONObjectBase");
/**
 * Represents a package.
 */
class Package extends JSONObjectBase_1.JSONObjectBase {
    /**
     * Initializes a new instance of the `Package` class.
     *
     * @param args
     * The passed arguments.
     */
    constructor(...args) {
        super();
        /**
         * The generation-logic for the properties.
         */
        this.generationLogics = new Map([
            ["maintainers", GenerationLogic_1.GenerationLogic.NonEmpty],
            ["contributors", GenerationLogic_1.GenerationLogic.NonEmpty],
            ["keywords", GenerationLogic_1.GenerationLogic.NonEmpty],
            ["engines", GenerationLogic_1.GenerationLogic.NonEmpty],
            ["browser", GenerationLogic_1.GenerationLogic.NonEmpty],
            ["bin", GenerationLogic_1.GenerationLogic.NonEmpty],
            ["man", GenerationLogic_1.GenerationLogic.NonEmpty],
            ["directories", GenerationLogic_1.GenerationLogic.NonEmpty],
            ["config", GenerationLogic_1.GenerationLogic.NonEmpty],
            ["publishConfig", GenerationLogic_1.GenerationLogic.NonEmpty],
            ["scripts", GenerationLogic_1.GenerationLogic.Always],
            ["dependencies", GenerationLogic_1.GenerationLogic.Always],
            ["devDependencies", GenerationLogic_1.GenerationLogic.Always],
            ["peerDependencies", GenerationLogic_1.GenerationLogic.NonEmpty],
            ["optionalDependencies", GenerationLogic_1.GenerationLogic.NonEmpty],
            ["bundledDependencies", GenerationLogic_1.GenerationLogic.NonEmpty]
        ]);
        let path = null;
        let metadata;
        if (args.length === 2) {
            path = args[0];
            metadata = args[1];
        }
        else {
            switch (typeof args[0]) {
                case "string":
                    path = args[0];
                    metadata = JSON.parse(fs_1.readFileSync(args[0]).toString());
                    break;
                default:
                    metadata = args[0];
                    break;
            }
        }
        this.FileName = path;
        this.LoadMetadata(metadata !== null && metadata !== void 0 ? metadata : {});
    }
    /**
     * @inheritdoc
     */
    get Dependencies() {
        return this.DependencyCollection.Dependencies;
    }
    /**
     * @inheritdoc
     */
    get DevelpomentDependencies() {
        return this.DependencyCollection.DevelpomentDependencies;
    }
    /**
     * @inheritdoc
     */
    get PeerDependencies() {
        return this.DependencyCollection.PeerDependencies;
    }
    /**
     * @inheritdoc
     */
    get OptionalDependencies() {
        return this.DependencyCollection.OptionalDependencies;
    }
    /**
     * @inheritdoc
     */
    get BundledDependencies() {
        return this.DependencyCollection.BundledDependencies;
    }
    /**
     * @inheritdoc
     */
    get AllDependencies() {
        return this.DependencyCollection.AllDependencies;
    }
    /**
     * Gets the default values for the options.
     */
    get Defaults() {
        return this.LoadDictionary({
            author: { name: null },
            maintainers: [],
            contributors: [],
            keywords: [],
            engines: {},
            browser: {},
            bin: {},
            man: [],
            directories: {},
            repository: null,
            config: {},
            publishConfig: {},
            scripts: {},
            dependencies: {},
            devDependencies: {},
            peerDependencies: {},
            optionalDependencies: {},
            bundledDependencies: []
        });
    }
    /**
     * Gets the mapping from the `IPackageMetadata`-properties to the `Package` properties.
     */
    get PropertyMap() {
        return new Map([
            ["name", "Name"],
            ["version", "Version"],
            ["private", "Private"],
            ["description", "Description"],
            ["author", "Author"],
            ["maintainers", "Maintainers"],
            ["contributors", "Contributors"],
            ["license", "License"],
            ["keywords", "Keywords"],
            ["engines", "Engines"],
            ["os", "OS"],
            ["cpu", "CPU"],
            ["main", "Main"],
            ["types", "Types"],
            ["browser", "Browser"],
            ["bin", "Binaries"],
            ["man", "Manuals"],
            ["files", "Files"],
            ["directories", "Directories"],
            ["homepage", "Homepage"],
            ["repository", "Repository"],
            ["bugs", "Bugs"],
            ["config", "Config"],
            ["publishConfig", "PublishConfig"],
            ["scripts", "Scripts"],
            ["dependencies", "Dependencies"],
            ["devDependencies", "DevelpomentDependencies"],
            ["peerDependencies", "PeerDependencies"],
            ["optionalDependencies", "OptionalDependencies"],
            ["bundledDependencies", "BundledDependencies"]
        ]);
    }
    /**
     * Gets the load-logic for the properties.
     */
    get LoadLogics() {
        return new Map([
            ["author", LoadLogic_1.LoadLogic.Person],
            ["maintainers", LoadLogic_1.LoadLogic.PersonList],
            ["contributors", LoadLogic_1.LoadLogic.PersonList],
            ["engines", LoadLogic_1.LoadLogic.Dictionary],
            ["bugs", LoadLogic_1.LoadLogic.BugInfo],
            ["scripts", LoadLogic_1.LoadLogic.Dictionary],
            ["dependencies", LoadLogic_1.LoadLogic.None],
            ["devDependencies", LoadLogic_1.LoadLogic.None],
            ["peerDependencies", LoadLogic_1.LoadLogic.None],
            ["optionalDependencies", LoadLogic_1.LoadLogic.None],
            ["bundledDependencies", LoadLogic_1.LoadLogic.None]
        ]);
    }
    /**
     * Gets the generation-logic for the properties.
     */
    get GenerationLogics() {
        return this.generationLogics;
    }
    /**
     * @inheritdoc
     *
     * @param collection
     * The collection to register.
     *
     * @param overwrite
     * A value indicating whether existing dependencies should be overwritten.
     */
    Register(collection, overwrite) {
        this.DependencyCollection.Register(collection, overwrite);
    }
    /**
     * Normalizes the package-metadata.
     */
    Normalize() {
        return __awaiter(this, void 0, void 0, function* () {
            let directory = null;
            let metadata = Object.assign({}, this.ToJSON());
            if (this.FileName) {
                let packageRoot = Path.dirname(Path.resolve(this.FileName));
                if (yield fs_extra_1.pathExists(packageRoot)) {
                    let gitRoot = yield gitRootDir(packageRoot);
                    let readmeFile = yield readmeFilename(packageRoot);
                    if (gitRoot) {
                        let remote;
                        try {
                            remote = yield gitRemoteOriginUrl(gitRoot);
                        }
                        catch (_a) {
                            remote = null;
                        }
                        metadata.repository = remote;
                        if (Path.resolve(gitRoot) !== Path.resolve(packageRoot)) {
                            directory = Path.relative(gitRoot, packageRoot);
                        }
                    }
                    if (readmeFile) {
                        metadata.readme = (yield fs_extra_1.readFile(Path.join(packageRoot, readmeFile))).toString();
                    }
                }
            }
            normalize(metadata);
            let newMetadata = Object.assign(Object.assign({}, this.ToJSON()), { description: metadata.description, bin: metadata.bin, man: metadata.man, repository: metadata.repository, bugs: metadata.bugs, homepage: metadata.homepage });
            if (directory !== null) {
                if (newMetadata.repository &&
                    typeof newMetadata.repository !== "string") {
                    newMetadata.repository.directory = directory;
                }
            }
            this.LoadMetadata(newMetadata);
        });
    }
    /**
     * Gets a json-object representing this package.
     *
     * @returns
     * A json-object representing this package.
     */
    ToJSON() {
        let result = new JSONObject_1.JSONObject();
        for (let entry of this.PropertyMap.entries()) {
            let value = this[entry[1]];
            let logic = GenerationLogic_1.GenerationLogic.Default;
            if (value instanceof JSONObjectBase_1.JSONObjectBase) {
                value = value.ToJSON();
            }
            if (this.GenerationLogics.has(entry[0])) {
                logic = this.GenerationLogics.get(entry[0]);
            }
            switch (logic) {
                case GenerationLogic_1.GenerationLogic.NonEmpty:
                    result.AddIfNotEmpty(entry[0], value);
                    break;
                case GenerationLogic_1.GenerationLogic.Always:
                    result.Add(entry[0], value);
                    break;
                case GenerationLogic_1.GenerationLogic.NonNull:
                default:
                    result.AddIfNotNull(entry[0], value);
                    break;
            }
        }
        for (let property of this.AdditionalProperties.Entries) {
            result.Add(property[0], property[1]);
        }
        return result.ToJSON();
    }
    /**
     * Loads package-metadata.
     *
     * @param metadata
     * The matadata to load.
     */
    LoadMetadata(metadata) {
        for (let entry of this.PropertyMap) {
            let value = metadata[entry[0]];
            if (this.Defaults.Has(entry[0])) {
                value = value !== null && value !== void 0 ? value : this.Defaults.Get(entry[0]);
            }
            Object.assign(metadata, {
                [entry[0]]: value
            });
        }
        let additionalProperties = {};
        let metaDictionary = new PropertyDictionary_1.PropertyDictionary(metadata);
        this.DependencyCollection = this.LoadDependencyCollection(metadata);
        for (let entry of metaDictionary.Entries) {
            let key = entry[0];
            let value = metaDictionary.Get(entry[0]);
            if (this.PropertyMap.has(key)) {
                let logic = this.LoadLogics.get(key);
                if (logic !== LoadLogic_1.LoadLogic.None) {
                    switch (logic) {
                        case LoadLogic_1.LoadLogic.Dictionary:
                            value = this.LoadDictionary(value);
                            break;
                        case LoadLogic_1.LoadLogic.Person:
                            value = this.LoadPerson(value);
                            break;
                        case LoadLogic_1.LoadLogic.PersonList:
                            value = this.LoadPersonList(value);
                            break;
                        case LoadLogic_1.LoadLogic.BugInfo:
                            value = new BugInfo_1.BugInfo(value);
                            break;
                        case LoadLogic_1.LoadLogic.Plain:
                        default:
                            value = this.LoadObject(value);
                            break;
                    }
                    Object.assign(this, {
                        [this.PropertyMap.get(key)]: value
                    });
                }
            }
            else {
                Object.assign(additionalProperties, {
                    [entry[0]]: entry[1]
                });
            }
        }
        this.AdditionalProperties = this.LoadDictionary(additionalProperties);
    }
    /**
     * Loads an object.
     *
     * @param object
     * The object to load.
     *
     * @returns
     * The loaded object.
     */
    LoadObject(object) {
        return (object !== null && object !== undefined) ?
            (typeof object === "object" ? (Array.isArray(object) ? [...object] : Object.assign({}, object)) : object) :
            null;
    }
    /**
     * Loads a dictionary from an object.
     *
     * @param collection
     * The collection to load.
     *
     * @returns
     * The loaded dictionary.
     */
    LoadDictionary(collection) {
        return new PropertyDictionary_1.PropertyDictionary(collection);
    }
    /**
     * Loads a dependency-collection.
     *
     * @param collection
     * The dependency-collection to load.
     *
     * @returns
     * The newly created dependency-collection.
     */
    LoadDependencyCollection(collection) {
        return new OrderedDependencyCollection_1.OrderedDependencyCollection(collection);
    }
    /**
     * Loads a person from an object.
     *
     * @param person
     * The person to load.
     *
     * @returns
     * The loaded person.
     */
    LoadPerson(person) {
        return new Person_1.Person(person);
    }
    /**
     * Loads a set of persons from an object.
     *
     * @param personList
     * The person-list to load.
     *
     * @returns
     * The loaded list.
     */
    LoadPersonList(personList) {
        return personList.map((person) => this.LoadPerson(person));
    }
}
exports.Package = Package;
//# sourceMappingURL=Package.js.map