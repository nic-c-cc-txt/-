"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dictionary = void 0;
const JSONObject_1 = require("../Utilities/JSONObject");
const Collection_1 = require("./Collection");
/**
 * Provides the functionality to store key-value pairs.
 *
 * @template TKey
 * The type of the keys of the dictionary.
 *
 * @template TValue
 * The type of the values of the dictionary.
 */
class Dictionary extends Collection_1.Collection {
    /**
     * Initializes a new instance of the `Dictionary` class.
     *
     * @param args
     * The passed arguments.
     */
    constructor(...args) {
        super();
        /**
         * The actual collection.
         */
        this.innerCollection = new Map();
        if (args.length > 0) {
            this.AddRange(...args);
        }
    }
    /**
     * @inheritdoc
     */
    get Count() {
        return this.innerCollection.size;
    }
    /**
     * @inheritdoc
     */
    get Entries() {
        return Array.from(this.innerCollection.entries());
    }
    /**
     * @inheritdoc
     *
     * @param key
     * The key of the entry to add.
     *
     * @param value
     * The value of the entry to add.
     */
    Add(key, value) {
        if (this.Has(key)) {
            throw new RangeError();
        }
        else {
            this.innerCollection.set(key, value);
        }
    }
    /**
     * @inheritdoc
     *
     * @param entries
     * The entries to add.
     */
    AddRange(entries) {
        if (entries instanceof Dictionary) {
            entries = entries.Entries;
        }
        for (let entry of entries) {
            this.Add(entry[0], entry[1]);
        }
    }
    /**
     * @inheritdoc
     *
     * @param key
     * The key of the entry to remove.
     */
    Remove(key) {
        if (!this.innerCollection.delete(key)) {
            throw new RangeError();
        }
    }
    /**
     * @inheritdoc
     *
     * @param key
     * The `key` of the entry whose value to get.
     *
     * @returns
     * The value of the entry with the specified `key`.
     */
    Get(key) {
        if (!this.Has(key)) {
            throw new RangeError();
        }
        else {
            return this.innerCollection.get(key);
        }
    }
    /**
     * @inheritdoc
     *
     * @param key
     * The `key` of the entry whose value to set.
     *
     * @param value
     * The value to set for the specified `key`.
     */
    Set(key, value) {
        if (!this.Has(key)) {
            throw new RangeError();
        }
        else {
            this.innerCollection.set(key, value);
        }
    }
    /**
     * @inheritdoc
     *
     * @param key
     * The `key` of the entry to check.
     *
     * @returns
     * A value indicating whether the dictionary contains an entryx with the specified `key`.
     */
    Has(key) {
        return this.innerCollection.has(key);
    }
    /**
     * @inheritdoc
     */
    Clear() {
        this.innerCollection.clear();
    }
    /**
     * @inheritdoc
     *
     * @returns
     * An object representing this collection.
     */
    ToJSON() {
        return this.Entries.reduce((result, entry) => {
            result.Add(`${entry[0]}`, entry[1]);
            return result;
        }, new JSONObject_1.JSONObject()).ToJSON();
    }
}
exports.Dictionary = Dictionary;
//# sourceMappingURL=Dictionary.js.map